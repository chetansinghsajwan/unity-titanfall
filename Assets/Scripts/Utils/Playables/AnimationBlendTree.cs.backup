using System;
using UnityEngine.Animations;

namespace UnityEngine.Playables
{
    public abstract class AnimationBlendTree<P> : Motion
        where P : struct, IEquatable<P>
    {
        protected interface INodeElement
        {
            public float GetLength();
            public Playable GetPlayable();
        }

        protected struct AnimationClipNodeElement : INodeElement
        {
            public float GetLength()
            {
                if (clip == null)
                {
                    return 0f;
                }

                return clip.length;
            }

            public Playable GetPlayable()
            {
                return playable;
            }

            AnimationClipPlayable playable;
            AnimationClip clip;
        }

        protected struct BlendTreeNodeElement : INodeElement
        {
            public float GetLength()
            {
                if (tree == null)
                {
                    return 0f;
                }

                return tree.BlendedClipLength;
            }

            public Playable GetPlayable()
            {
                return tree.Mixer;
            }

            AnimationBlendTree<P> tree;
        }

        protected struct Node
        {
            public INodeElement element;
            public P position;
            public float speed;
            public float weight;
        }

        ~AnimationBlendTree()
        {
            if (_mixer.IsValid())
            {
                _mixer.Destroy();
            }
        }

        public AnimationBlendTree(PlayableGraph graph, int capacity = 0)
        {
            _graph = graph;
            _mixer = AnimationMixerPlayable.Create(_graph, capacity);
            _blendPosition = default;
            _nodes = new Node[capacity];
            _blendedClipLength = 0f;
            _masterSpeed = 1f;
            _footIk = false;
            _count = 0;
        }

        public void AddPlayable(Playable playable, float pos = 0f)
        {
        }

        protected void AddNode(Node node, bool? updateGraph = null)
        {
            // prepare the node
            node.weight = 0f;

            if (node.clip != null)
            {
                node.clipLength = 0f;
            }
            else
            {
                node.clipLength = node.clip.length;
            }

            // increase capacity if not enough
            if (_count == _nodes.Length)
            {
                Reserve(_nodes.Length + 1);
            }

            // AnimationClipPlayable clipPlayable = AnimationClipPlayable.Create(_graph, node.clip);
            // _mixer.ConnectInput(_count, clipPlayable, 0);
            // _mixer.SetInputWeight(_count, 0f);
            _nodes[_count] = node;
            _count++;

            if (updateGraph.HasValue == false)
            {
                updateGraph = true;
            }

            if (updateGraph.Value)
            {
                UpdateGraph(true);
            }
        }

        public void AddAnimation(AnimationClip clip, P position, float speed = 1f, bool? updateGraph = null)
        {
            Node node = new Node();
            node.clip = clip;
            node.position = position;
            node.speed = speed;

            AddNode(node, updateGraph);
        }

        public bool SetAnimation(AnimationClip source, AnimationClip clip, bool? updateGraph = null)
        {
            for (int i = 0; i < _count; i++)
            {
                if (_nodes[i].clip == source)
                {
                    return SetAnimation(i, clip, updateGraph);
                }
            }

            return false;
        }

        public bool SetAnimation(int index, AnimationClip clip, bool? updateGraph = null)
        {
            if (index < 0 || index > _count - 1)
            {
                return false;
            }

            float prevClipLength = _nodes[index].clipLength;
            _nodes[index].clip = clip;

            if (clip == null)
            {
                _nodes[index].clipLength = 0f;
            }
            else
            {
                _nodes[index].clipLength = clip.length;
            }

            if (updateGraph.HasValue == false)
            {
                // only change value if not provided by the user
                if (prevClipLength == _nodes[index].clipLength)
                {
                    // if length not changed, graph remains unaffected
                    updateGraph = false;
                }
                else
                {
                    updateGraph = true;
                }
            }

            if (updateGraph.Value)
            {
                // no need to recalculate weights, if positions are unchanged
                UpdateGraph(false);
            }

            return true;
        }

        public bool SetPosition(AnimationClip clip, P position, bool? updateGraph = null)
        {
            for (int i = 0; i < _count; i++)
            {
                if (_nodes[i].clip == clip)
                {
                    return SetPosition(i, position, updateGraph);
                }
            }

            return false;
        }

        public bool SetPosition(int index, P position, bool? updateGraph = null)
        {
            if (index < 0 || index > _count - 1)
            {
                return false;
            }

            if (updateGraph.HasValue == false)
            {
                if (_nodes[index].position.Equals(position))
                {
                    updateGraph = false;
                }
                else
                {
                    updateGraph = true;
                }
            }

            _nodes[index].position = position;

            if (updateGraph.Value)
            {
                UpdateGraph(true);
            }

            return true;
        }

        public bool SetSpeed(AnimationClip source, float speed, bool? updateGraph = null)
        {
            for (int i = 0; i < _count; i++)
            {
                if (_nodes[i].clip == source)
                {
                    return SetSpeed(i, speed, updateGraph);
                }
            }

            return false;
        }

        public bool SetSpeed(int index, float speed, bool? updateGraph = null)
        {
            if (index < 0 || index > _count - 1)
            {
                return false;
            }

            if (updateGraph.HasValue == false)
            {
                if (_nodes[index].speed == speed)
                {
                    updateGraph = false;
                }
                else
                {
                    updateGraph = true;
                }
            }

            _nodes[index].speed = speed;

            if (updateGraph.Value)
            {
                // no need to recalculate weights, if positions are unchanged
                UpdateGraph(false);
            }

            return true;
        }

        public void SetBlendPosition(P position, bool? updateGraph = null)
        {
            if (updateGraph.HasValue == false)
            {
                if (_blendPosition.Equals(position))
                {
                    updateGraph = false;
                }
                else
                {
                    updateGraph = true;
                }
            }

            _blendPosition = position;

            if (updateGraph.Value)
            {
                UpdateGraph(true);
            }
        }

        public void SetMasterSpeed(float speed, bool? updateGraph = null)
        {
            if (updateGraph.HasValue == false)
            {
                if (_masterSpeed == speed)
                {
                    updateGraph = false;
                }
                else
                {
                    updateGraph = true;
                }
            }

            if (_masterSpeed != speed)
            {
                _blendedClipLength = _blendedClipLength * _masterSpeed;
                _blendedClipLength = _blendedClipLength / speed;
                _masterSpeed = speed;
            }

            if (updateGraph.Value)
            {
                UpdateGraph(false);
            }
        }

        public void SetFootIK(bool ik, bool? updateGraph = null)
        {
            if (updateGraph.HasValue == false)
            {
                if (_footIk == ik)
                {
                    updateGraph = false;
                }
                else
                {
                    updateGraph = true;
                }
            }

            _footIk = ik;

            if (updateGraph.Value)
            {
                UpdateGraph(false);
            }
        }

        public void Reserve(int capacity)
        {
            capacity = Mathf.Max(capacity, _count);
            Array.Resize(ref _nodes, capacity);
        }

        public abstract void UpdateWeights();

        public void UpdateTree(bool updateWeights = false)
        {
            if (updateWeights)
            {
                UpdateWeights();
            }

            // update _blendedClipLength
            _blendedClipLength = 0f;
            for (var i = 0; i < _count; i++)
            {
                var node = _nodes[i];

                if (node.clipLength > 0f)
                {
                    _blendedClipLength += (node.clipLength / node.speed) * node.weight;
                }
            }

            _blendedClipLength /= _masterSpeed;
        }

        public void UpdateGraph(bool updateWeights = false)
        {
            if (updateWeights)
            {
                UpdateTree(updateWeights);
            }

            int count = Mathf.Min(_count, _mixer.GetInputCount());
            for (int i = 0; i < count; i++)
            {
                _mixer.SetInputWeight(i, _nodes[i].weight);

                try
                {
                    AnimationClipPlayable clipPlayable = (AnimationClipPlayable)_mixer.GetInput(i);
                    float speed = 0f;

                    if (_blendedClipLength != 0f)
                    {
                        speed = _nodes[i].clipLength / _blendedClipLength;
                    }

                    clipPlayable.SetSpeed(speed);
                    clipPlayable.SetApplyFootIK(_footIk);
                }
                catch (Exception) { }
            }
        }

        public void RebuildTree(bool rebuildAll = false)
        {
            int inputCount = 0;
            if (rebuildAll == false)
            {
                inputCount = _mixer.GetInputCount();
            }

            _mixer.SetInputCount(_count);
            for (int i = inputCount; i < _count; i++)
            {
                if (_nodes[i].playable.IsNull())
                {
                    _nodes[i].playable = AnimationClipPlayable.Create(
                        _graph, _nodes[i].clip);
                }

                _mixer.ConnectInput(i, _nodes[i].playable, 0, _nodes[i].weight);
            }
        }

        public PlayableGraph Graph => _graph;
        public AnimationMixerPlayable Mixer => _mixer;
        public P BlendPosition => _blendPosition;
        public float BlendedClipLength => _blendedClipLength;
        public float MasterSpeed => _masterSpeed;
        public bool FootIk => _footIk;
        public int Count => _count;
        public int Capacity => _nodes.Length;

        protected PlayableGraph _graph;
        protected AnimationMixerPlayable _mixer;
        protected P _blendPosition;
        protected Node[] _nodes;
        protected float _blendedClipLength;
        protected float _masterSpeed;
        protected bool _footIk;
        protected int _count;
    }
}